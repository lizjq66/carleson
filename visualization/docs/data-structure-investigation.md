# Astrolabe Data Structure Investigation

This document summarizes the data structures used in Astrolabe for storing graph data, user customizations, and canvas state.

## File Overview

| File | Location | Purpose | Read/Write |
|------|----------|---------|------------|
| `graph.json` | `.astrolabe/graph.json` | Parsed Lean declarations and dependencies | Read-only (generated) |
| `meta.json` | `.astrolabe/meta.json` | User customizations (notes, effects, colors, custom nodes/edges) | Read/Write |
| `canvas.json` | `.astrolabe/canvas.json` | Canvas state (visible nodes, positions, viewport) | Read/Write |

---

## 1. graph.json

**Purpose**: Cached output from parsing `.ilean` files. Contains all Lean declarations and their dependency edges.

**Generated by**: `backend/astrolabe/parsers/ilean_parser.py` → `parse_project_from_cache()`

**Structure**:
```json
{
  "version": "1.0",
  "generated_at": "2026-01-13T15:42:10.224994Z",
  "ilean_hash": "c5620a32c5f2ba0cc4a060b0cdb6fe45",
  "nodes": [...],
  "edges": [...]
}
```

### Node Fields
| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Fully qualified name (e.g., `Module.Name.theorem_name`) |
| `name` | string | Short name (e.g., `theorem_name`) |
| `kind` | string | Declaration type: `theorem`, `lemma`, `definition`, `axiom`, `structure`, `class`, `instance`, `inductive`, `example` |
| `file_path` | string | Absolute path to source `.lean` file |
| `line_number` | int | Line number in source file (1-indexed) |
| `references` | array | Empty (reserved) |
| `depends_on_count` | int | Number of declarations this node depends on |
| `used_by_count` | int | Number of declarations that use this node |
| `depth` | int | Graph depth from leaf nodes |
| `default_color` | string | Hex color based on kind |
| `default_size` | float | Size based on importance |
| `default_shape` | string | 3D shape: `sphere`, `tetrahedron`, `box`, `icosahedron` |

### Edge Fields
| Field | Type | Description |
|-------|------|-------------|
| `source` | string | Source node ID (the node that uses/depends on target) |
| `target` | string | Target node ID (the node being used/depended on) |
| `from_lean` | bool | Always `true` for parsed edges |
| `default_color` | string | Hex color |
| `default_width` | float | Line width |
| `default_style` | string | Line style: `solid` |

---

## 2. meta.json

**Purpose**: Stores user customizations. Only created when user adds notes, effects, colors, or creates custom nodes/edges.

**Managed by**: `backend/astrolabe/unified_storage.py` → `UnifiedStorage` class

**Structure**:
```json
{
  "nodes": {
    "<node_id>": {
      "notes": "# Markdown notes...",
      "size": 1.2,
      "effect": "polyhedron-shell",
      "color": "#ff0000"
    }
  },
  "edges": {
    "<source>-><target>": {
      "source": "<source_id>",
      "target": "<target_id>",
      "type": "custom",
      "style": "dashed",
      "effect": "data-stream",
      "color": "#00ff00",
      "width": 2.0,
      "notes": "Edge notes..."
    }
  },
  "macros": {}
}
```

### Node Meta Fields (style overrides)
| Field | Type | Description |
|-------|------|-------------|
| `notes` | string | Markdown notes with KaTeX support |
| `size` | float | Size override |
| `effect` | string | Visual effect ID (e.g., `pulse-glow`, `orbit-moons`) |
| `color` | string | Color override (hex) |

### Custom Node Fields (stored in `nodes` with `custom-*` ID)
| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Node display name |
| `kind` | string | Always `custom` |
| `references` | array | List of target node IDs this node depends on |
| `notes`, `size`, `effect`, `color` | various | Same as style overrides |

### Edge Meta Fields
| Field | Type | Description |
|-------|------|-------------|
| `source` | string | Source node ID |
| `target` | string | Target node ID |
| `type` | string | `custom` for user edges, `reference` for Lean edges |
| `style` | string | Line style: `solid`, `dashed`, `dotted`, `wavy`, `zigzag`, `spring` |
| `effect` | string | Visual effect ID |
| `color` | string | Color override |
| `width` | float | Width override |
| `notes` | string | Edge notes |

---

## 3. canvas.json

**Purpose**: Stores the current canvas state - which nodes are visible, their 3D positions, and camera viewport.

**Managed by**: `backend/astrolabe/canvas.py` → `CanvasStore` class

**Structure**:
```json
{
  "version": "1.1",
  "updated_at": "2026-01-13T19:53:56.636468Z",
  "visible_nodes": [
    "Module.Name.theorem1",
    "Module.Name.theorem2"
  ],
  "positions": {
    "Module.Name.theorem1": {"x": 1.0, "y": 2.0, "z": 3.0}
  },
  "viewport": {
    "camera_position": [14.9, -6.1, 13.0],
    "camera_target": [-1.9, -6.1, 2.3],
    "zoom": 1.0,
    "selected_node_id": "Module.Name.theorem1"
  }
}
```

### Canvas Fields
| Field | Type | Description |
|-------|------|-------------|
| `visible_nodes` | array | List of node IDs currently on canvas |
| `positions` | object | Map of node ID to `{x, y, z}` coordinates |
| `viewport.camera_position` | array | 3D camera position `[x, y, z]` |
| `viewport.camera_target` | array | 3D point camera looks at |
| `viewport.zoom` | float | Zoom level (reserved for 2D) |
| `viewport.selected_node_id` | string | Currently selected node |

---

## 4. .ilean Parsing Logic

**Location**: `backend/astrolabe/parsers/ilean_parser.py`

### Key Functions

1. **`parse_project_from_cache(project_root)`**
   - Entry point for parsing a Lean project
   - Scans `.lake/build/lib/lean/{project_name}/*.ilean`
   - Excludes dependencies (Mathlib, Batteries, etc.)
   - Returns `(nodes, edges)`

2. **`parse_ilean_file(ilean_path, project_root)`**
   - Parses a single `.ilean` file (JSON format)
   - Extracts `references` field containing declaration usage info
   - Returns `(nodes, imports, usage_map)`

3. **`infer_kind(content)`**
   - Determines declaration type from source code
   - Handles modifiers: `noncomputable`, `protected`, `private`, etc.
   - Maps to: `theorem`, `lemma`, `definition`, `axiom`, etc.

4. **`extract_full_declaration(lines, line_start)`**
   - Extracts full declaration content from source
   - Used for sorry detection and kind inference

### .ilean File Format
The `.ilean` file is a JSON index generated by Lean compilation:
```json
{
  "module": "Module.Name",
  "directImports": ["Mathlib.Data.Nat", ...],
  "references": {
    "{\"c\":{\"m\":\"Module.Name\",\"n\":\"theorem_name\"}}": {
      "definition": [line, col, end_line, end_col],
      "usages": [[line, col, end_line, end_col, "user_name"], ...]
    }
  }
}
```

**Important**: `.ilean` does NOT store declaration types (theorem/def/lemma). The parser must read source code to infer kind.

---

## File Relationships

```
.lake/build/lib/lean/*.ilean  ──parse──►  graph.json (read-only cache)
                                              │
                                              ▼
                                    ┌─────────────────┐
                                    │  UnifiedStorage │
                                    │   (merge data)  │
                                    └────────┬────────┘
                                             │
                              ┌──────────────┼──────────────┐
                              ▼              ▼              ▼
                         graph.json    meta.json     canvas.json
                         (Lean data)   (user data)   (UI state)
```

---

## Changes Needed for Shortcut Edges

A "shortcut edge" would be an edge that represents a transitive dependency (A→C when A→B→C exists), for visual clarity.

### Potential Approaches

1. **Compute at Parse Time** (`graph.json`)
   - Add `is_shortcut: bool` field to edges
   - Compute transitive closure during parsing
   - Pro: No frontend changes needed
   - Con: Increases edge count significantly

2. **Compute at Runtime** (frontend)
   - Add toggle to show/hide shortcut edges
   - Compute on-demand when displaying subgraph
   - Pro: User can control visibility
   - Con: Performance concerns for large graphs

3. **Store as Meta** (`meta.json`)
   - Allow users to mark edges as "shortcuts"
   - Add `is_shortcut: bool` to edge meta
   - Pro: User-controlled, persisted
   - Con: Manual classification

### Recommended Changes

1. **`models/edge.py`**: Add `is_shortcut` field to Edge model
2. **`graph_cache.py`**: Add shortcut edge computation during cache build
3. **`unified_storage.py`**: Support `is_shortcut` in edge meta
4. **Frontend**: Add UI toggle for shortcut edge visibility
5. **Edge3D.tsx**: Add visual distinction for shortcut edges (e.g., different color/style)
