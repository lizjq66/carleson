"""
Unified Storage

Unified Node/Edge storage system:
- graph_data: Read-only data from graph.json (generated by Lean parsing)
- meta_path: Path to meta.json (user data, read/write)

API design principles:
- Lean node/edge identity information (name, kind, file_path, etc.) comes from graph_data and cannot be modified
- Lean node/edge style overrides (color, size, notes, etc.) are stored in meta.json
- User node/edge complete data is stored in meta.json
- Edge type: "reference" (Lean) or "custom" (User)
"""

import json
from pathlib import Path
from typing import Optional


class UnifiedStorage:
    """Unified Node/Edge storage manager"""

    # Default viewport settings
    DEFAULT_VIEWPORT = {
        "camera_position": [0, 0, 20],
        "camera_target": [0, 0, 0],
        "zoom": 1.0,
        "selected_node_id": None,
        "selected_edge_id": None,
    }

    def __init__(self, graph_data: dict, meta_path: Path, project_path: Path = None):
        """
        Initialize storage manager

        Args:
            graph_data: Contents of graph.json (read-only, Lean parsing data)
            meta_path: Path to meta.json (read/write, user data)
            project_path: Path to project root (for canvas.json migration)
        """
        self._graph_data = graph_data
        self._meta_path = meta_path
        self._project_path = project_path
        self._meta = self._load_meta()

        # Migrate canvas.json if needed
        if project_path:
            self._migrate_canvas_if_needed()

        # Build index of Lean nodes/edges for convenient querying
        self._lean_node_ids = {n["id"] for n in graph_data.get("nodes", [])}
        self._lean_edge_ids = {
            f"{e['source']}->{e['target']}" for e in graph_data.get("edges", [])
        }

        # Build dictionary index of Lean nodes for fast lookup
        self._lean_nodes_by_id = {n["id"]: n for n in graph_data.get("nodes", [])}
        self._lean_edges_by_id = {
            f"{e['source']}->{e['target']}": e for e in graph_data.get("edges", [])
        }

    def _load_meta(self) -> dict:
        """Load meta.json"""
        if self._meta_path.exists():
            data = json.loads(self._meta_path.read_text(encoding="utf-8"))
            # Ensure canvas structure exists (positions and viewport only)
            if "canvas" not in data:
                data["canvas"] = {
                    "positions": {},
                    "viewport": self.DEFAULT_VIEWPORT.copy(),
                }
            # Migrate old visible_nodes array to nodes.<id>.visible if present
            if "visible_nodes" in data.get("canvas", {}):
                visible_nodes = data["canvas"].pop("visible_nodes", [])
                if "nodes" not in data:
                    data["nodes"] = {}
                for node_id in visible_nodes:
                    if node_id not in data["nodes"]:
                        data["nodes"][node_id] = {}
                    data["nodes"][node_id]["visible"] = True
            return data
        return {
            "nodes": {},
            "edges": {},
            "canvas": {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            },
        }

    def _save_meta(self):
        """Save meta.json"""
        self._meta_path.parent.mkdir(parents=True, exist_ok=True)
        self._meta_path.write_text(
            json.dumps(self._meta, indent=2, ensure_ascii=False), encoding="utf-8"
        )

    # =========================================
    # Node operations (only modify meta.json)
    # =========================================

    def add_user_node(
        self,
        node_id: str,
        name: str,
        kind: str = "custom",
        references: list[str] = None,
        **kwargs,
    ) -> dict:
        """
        Add User node

        Args:
            node_id: Node ID (format: custom-xxx)
            name: Node name (required)
            kind: Node type (default: custom)
            references: Dependency list
            **kwargs: Other attributes (notes, color, etc.)

        Returns:
            Created node data

        Raises:
            ValueError: If name or kind is empty
        """
        if not name:
            raise ValueError("name is required for user node")
        if not kind:
            raise ValueError("kind is required for user node")

        node_data = {
            "name": name,
            "kind": kind,
            "references": references if references is not None else [],
        }

        # Add other optional attributes
        for key, value in kwargs.items():
            if value is not None:
                node_data[key] = value

        self._meta["nodes"][node_id] = node_data
        self._save_meta()

        return {"id": node_id, **node_data}

    # Identity fields of Lean nodes should not be stored in meta
    _LEAN_IDENTITY_FIELDS = {"name", "kind", "file_path", "line_number", "status", "content", "references", "depends_on_count", "used_by_count", "depth"}

    def _should_delete(self, value) -> bool:
        """Check if value indicates deletion (empty string or -1)"""
        if value == "" or value == -1:
            return True
        return False

    def update_node_meta(self, node_id: str, **kwargs) -> bool:
        """
        Update node meta attributes

        For Lean nodes: Only store style override attributes (color, size, notes, etc.)
        For User nodes: Can update all attributes (including name)

        Special values:
        - Empty string "" or -1 indicates deletion of that attribute

        Args:
            node_id: Node ID
            **kwargs: Attributes to update

        Returns:
            Whether successful
        """
        if node_id not in self._meta["nodes"]:
            self._meta["nodes"][node_id] = {}

        # For Lean nodes, filter out identity fields
        if self.is_lean_node(node_id):
            for key, value in kwargs.items():
                if key not in self._LEAN_IDENTITY_FIELDS:
                    if self._should_delete(value):
                        # Delete this attribute
                        self._meta["nodes"][node_id].pop(key, None)
                    elif value is not None:
                        self._meta["nodes"][node_id][key] = value
        else:
            # User nodes can update all fields
            for key, value in kwargs.items():
                if self._should_delete(value):
                    # Delete this attribute
                    self._meta["nodes"][node_id].pop(key, None)
                elif value is not None:
                    self._meta["nodes"][node_id][key] = value

        # If node meta becomes empty, delete entire node entry
        if not self._meta["nodes"][node_id]:
            del self._meta["nodes"][node_id]

        self._save_meta()
        return True

    def delete_node(self, node_id: str) -> bool:
        """
        Delete node

        For User nodes: Actually delete, and cascade delete related edges
        For Lean nodes: Only clear meta override attributes

        Args:
            node_id: Node ID

        Returns:
            Whether successful
        """
        if self.is_user_node(node_id):
            # User node: Actually delete
            if node_id in self._meta["nodes"]:
                del self._meta["nodes"][node_id]

            # Cascade delete related edges (edges where source or target is this node)
            edges_to_delete = []
            for edge_id, edge_data in self._meta.get("edges", {}).items():
                source = edge_data.get("source")
                target = edge_data.get("target")
                # If no source/target fields, parse from edge_id
                if source is None or target is None:
                    parts = edge_id.split("->")
                    if len(parts) == 2:
                        source, target = parts
                if source == node_id or target == node_id:
                    edges_to_delete.append(edge_id)

            for edge_id in edges_to_delete:
                del self._meta["edges"][edge_id]

            # Update references in other User nodes (remove references to this node)
            for other_node_id, other_node_data in self._meta.get("nodes", {}).items():
                if self.is_user_node(other_node_id):
                    refs = other_node_data.get("references", [])
                    if node_id in refs:
                        refs.remove(node_id)
        else:
            # Lean node: Only clear meta
            if node_id in self._meta["nodes"]:
                del self._meta["nodes"][node_id]

        self._save_meta()
        return True

    def get_node_meta(self, node_id: str) -> Optional[dict]:
        """
        Get node meta data (only returns the part stored in meta.json)

        Args:
            node_id: Node ID

        Returns:
            Meta data, or None if not found
        """
        return self._meta.get("nodes", {}).get(node_id)

    def get_all_user_nodes(self) -> list[dict]:
        """
        Get all custom nodes (starting with custom-)

        Returns:
            List of User nodes
        """
        result = []
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if self.is_user_node(node_id):
                result.append({"id": node_id, **node_data})
        return result

    # =========================================
    # Edge operations (only modify meta.json)
    # =========================================

    def add_user_edge(
        self,
        source: str,
        target: str,
        **kwargs,
    ) -> dict:
        """
        Add User edge

        Also updates source node's references (if it's a User node)

        Args:
            source: Source node ID
            target: Target node ID
            **kwargs: Other attributes (notes, color, width, etc.)

        Returns:
            Created edge data (includes id, source, target, type="custom")
        """
        edge_id = f"{source}->{target}"

        edge_data = {
            "source": source,
            "target": target,
            "type": "custom",
        }

        # Add other optional attributes
        for key, value in kwargs.items():
            if value is not None:
                edge_data[key] = value

        self._meta["edges"][edge_id] = edge_data

        # If source is a User node, update its references
        if self.is_user_node(source) and source in self._meta.get("nodes", {}):
            refs = self._meta["nodes"][source].get("references", [])
            if target not in refs:
                refs.append(target)
                self._meta["nodes"][source]["references"] = refs

        self._save_meta()
        return {"id": edge_id, **edge_data}

    def update_edge_meta(self, edge_id: str, **kwargs) -> bool:
        """
        Update edge meta attributes

        Special values:
        - Empty string "" or -1 indicates deletion of that attribute

        Args:
            edge_id: Edge ID (format: source->target)
            **kwargs: Attributes to update (color, width, style, effect, notes)

        Returns:
            Whether successful
        """
        if edge_id not in self._meta["edges"]:
            self._meta["edges"][edge_id] = {}

        for key, value in kwargs.items():
            if self._should_delete(value):
                # Delete this attribute
                self._meta["edges"][edge_id].pop(key, None)
            elif value is not None:
                self._meta["edges"][edge_id][key] = value

        # If edge meta becomes empty (only source/target/type remaining), consider whether to keep
        # For custom edges, keep source/target/type
        # For Lean edges, delete entire entry if meta is empty
        edge_data = self._meta["edges"].get(edge_id, {})
        # Check if only basic fields remain
        meta_keys = set(edge_data.keys()) - {"source", "target", "type"}
        if not meta_keys and edge_id in self._lean_edge_ids:
            # Lean edge with no style overrides, delete entry
            del self._meta["edges"][edge_id]

        self._save_meta()
        return True

    def delete_edge(self, edge_id: str) -> bool:
        """
        Delete edge

        Can only delete User edges (type=custom), Lean edges cannot be deleted

        Also updates source node's references (if it's a User node)

        Args:
            edge_id: Edge ID

        Returns:
            Whether successful

        Raises:
            ValueError: If attempting to delete a Lean edge
        """
        # Check if it's a Lean edge (and not overridden to custom)
        if self.is_lean_edge(edge_id):
            edge_meta = self._meta.get("edges", {}).get(edge_id, {})
            if edge_meta.get("type") != "custom":
                raise ValueError("Cannot delete Lean edge")

        # Parse source and target
        parts = edge_id.split("->")
        if len(parts) == 2:
            source, target = parts

            # If source is a User node, update its references
            if self.is_user_node(source) and source in self._meta.get("nodes", {}):
                refs = self._meta["nodes"][source].get("references", [])
                if target in refs:
                    refs.remove(target)

        # Delete edge
        if edge_id in self._meta["edges"]:
            del self._meta["edges"][edge_id]

        self._save_meta()
        return True

    def get_edge_meta(self, edge_id: str) -> Optional[dict]:
        """
        Get edge meta data

        Args:
            edge_id: Edge ID

        Returns:
            Meta data, or None if not found
        """
        return self._meta.get("edges", {}).get(edge_id)

    def get_all_user_edges(self) -> list[dict]:
        """
        Get all User edges (type=custom)

        Returns:
            List of User edges
        """
        result = []
        for edge_id, edge_data in self._meta.get("edges", {}).items():
            if edge_data.get("type") == "custom":
                result.append({"id": edge_id, **edge_data})
        return result

    # =========================================
    # Merged queries (graph.json + meta.json)
    # =========================================

    def get_all_nodes(self) -> list[dict]:
        """
        Get all nodes (Lean + User, merged with meta)

        Returns:
            List of all merged nodes
        """
        result = []

        # Add Lean nodes (merged with meta)
        for lean_node in self._graph_data.get("nodes", []):
            node_id = lean_node["id"]
            merged = lean_node.copy()
            meta_data = self._meta.get("nodes", {}).get(node_id, {})
            merged.update(meta_data)
            result.append(merged)

        # Add User nodes
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if self.is_user_node(node_id):
                result.append({"id": node_id, **node_data})

        return result

    def get_all_edges(self) -> list[dict]:
        """
        Get all edges (Lean + User, merged with meta)

        Returns:
            List of all merged edges
        """
        result = []

        # Add Lean edges (merged with meta)
        for lean_edge in self._graph_data.get("edges", []):
            edge_id = f"{lean_edge['source']}->{lean_edge['target']}"
            merged = {
                "id": edge_id,
                "source": lean_edge["source"],
                "target": lean_edge["target"],
                "type": "reference",  # Lean edges default to reference type
            }
            meta_data = self._meta.get("edges", {}).get(edge_id, {})
            merged.update(meta_data)
            result.append(merged)

        # Add User edges (not in Lean edge collection)
        for edge_id, edge_data in self._meta.get("edges", {}).items():
            if edge_id not in self._lean_edge_ids:
                result.append({"id": edge_id, **edge_data})

        return result

    def get_node(self, node_id: str) -> Optional[dict]:
        """
        Get a single node (merged from graph_data and meta)

        Args:
            node_id: Node ID

        Returns:
            Merged node data, or None if not found
        """
        # Check if it's a Lean node
        if node_id in self._lean_nodes_by_id:
            # Merge Lean data and meta
            lean_data = self._lean_nodes_by_id[node_id].copy()
            meta_data = self._meta.get("nodes", {}).get(node_id, {})
            lean_data.update(meta_data)
            return lean_data

        # Check if it's a User node
        if node_id in self._meta.get("nodes", {}):
            node_data = self._meta["nodes"][node_id].copy()
            return {"id": node_id, **node_data}

        return None

    def get_edge(self, edge_id: str) -> Optional[dict]:
        """
        Get a single edge (merged from graph_data and meta)

        Args:
            edge_id: Edge ID

        Returns:
            Merged edge data, or None if not found
        """
        # Check if it's a Lean edge
        if edge_id in self._lean_edges_by_id:
            lean_edge = self._lean_edges_by_id[edge_id]
            merged = {
                "id": edge_id,
                "source": lean_edge["source"],
                "target": lean_edge["target"],
                "type": "reference",  # Lean edges default to reference type
            }
            meta_data = self._meta.get("edges", {}).get(edge_id, {})
            merged.update(meta_data)
            return merged

        # Check if it's a User edge
        if edge_id in self._meta.get("edges", {}):
            edge_data = self._meta["edges"][edge_id].copy()
            return {"id": edge_id, **edge_data}

        return None

    # =========================================
    # Helper methods
    # =========================================

    def is_user_node(self, node_id: str) -> bool:
        """Check if it's a custom node (starts with custom-)"""
        return node_id.startswith("custom-")

    def is_lean_node(self, node_id: str) -> bool:
        """Check if it's a Lean node (exists in graph_data)"""
        return node_id in self._lean_node_ids

    def is_user_edge(self, edge_id: str) -> bool:
        """Check if it's a User edge (type=custom or not in Lean edge collection)"""
        # If not in Lean edge collection, definitely a User edge
        if edge_id not in self._lean_edge_ids:
            return True
        # If in Lean edge collection, check if marked as custom in meta
        meta = self._meta.get("edges", {}).get(edge_id, {})
        return meta.get("type") == "custom"

    def is_lean_edge(self, edge_id: str) -> bool:
        """Check if it's a Lean edge (exists in graph_data)"""
        return edge_id in self._lean_edge_ids

    def clear(self):
        """
        Clear all meta data (nodes, edges, canvas)

        Note: This does not affect graph_data (Lean parsing data)
        """
        self._meta = {
            "nodes": {},
            "edges": {},
            "canvas": {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            },
        }
        self._save_meta()

    # =========================================
    # Canvas operations
    # =========================================

    def _migrate_canvas_if_needed(self):
        """
        Migrate old canvas.json to meta.json if needed.

        Migration:
        1. visible_nodes array -> nodes.<id>.visible = true
        2. positions -> canvas.positions
        3. viewport -> canvas.viewport
        """
        if not self._project_path:
            return

        canvas_path = self._project_path / ".astrolabe" / "canvas.json"
        if not canvas_path.exists():
            return

        # Check if already migrated (any node has visible property)
        for node_data in self._meta.get("nodes", {}).values():
            if "visible" in node_data:
                return  # Already migrated

        # Read old canvas.json
        try:
            canvas_data = json.loads(canvas_path.read_text(encoding="utf-8"))
        except (json.JSONDecodeError, IOError):
            # Corrupted or unreadable, skip migration
            return

        # Migrate visible_nodes to nodes.<id>.visible
        visible_nodes = canvas_data.get("visible_nodes", [])
        for node_id in visible_nodes:
            if node_id not in self._meta["nodes"]:
                self._meta["nodes"][node_id] = {}
            self._meta["nodes"][node_id]["visible"] = True

        # Migrate positions and viewport to canvas
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        self._meta["canvas"]["positions"] = canvas_data.get("positions", {})
        self._meta["canvas"]["viewport"] = canvas_data.get("viewport", self.DEFAULT_VIEWPORT.copy())

        # Save migrated data
        self._save_meta()

    def cleanup_old_canvas(self):
        """
        Delete old canvas.json after successful migration.

        Safe to call multiple times - does nothing if file doesn't exist.
        """
        if not self._project_path:
            return

        canvas_path = self._project_path / ".astrolabe" / "canvas.json"
        if canvas_path.exists():
            canvas_path.unlink()

    def get_canvas(self) -> dict:
        """
        Get full canvas data (for API compatibility).

        Returns:
            Canvas dict with visible_nodes (derived from nodes), positions, viewport
        """
        # Derive visible_nodes from nodes.<id>.visible
        visible_nodes = self.get_visible_nodes()
        canvas = self._meta.get("canvas", {})
        return {
            "visible_nodes": visible_nodes,
            "positions": canvas.get("positions", {}),
            "viewport": canvas.get("viewport", self.DEFAULT_VIEWPORT.copy()),
        }

    def set_canvas(self, data: dict):
        """
        Replace entire canvas data.

        Args:
            data: New canvas data (visible_nodes, positions, viewport)
        """
        # Set visibility for each node
        visible_nodes = data.get("visible_nodes", [])

        # First, clear all visible flags
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if "visible" in node_data:
                del node_data["visible"]

        # Then set visible=true for nodes in the list
        for node_id in visible_nodes:
            if node_id not in self._meta["nodes"]:
                self._meta["nodes"][node_id] = {}
            self._meta["nodes"][node_id]["visible"] = True

        # Clean up empty node entries
        self._meta["nodes"] = {k: v for k, v in self._meta["nodes"].items() if v}

        # Set positions and viewport
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        self._meta["canvas"]["positions"] = data.get("positions", {})
        self._meta["canvas"]["viewport"] = data.get("viewport", self.DEFAULT_VIEWPORT.copy())

        self._save_meta()

    def get_visible_nodes(self) -> list[str]:
        """
        Get list of visible node IDs.

        Returns:
            List of node IDs where visible=true
        """
        visible = []
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if node_data.get("visible") is True:
                visible.append(node_id)
        return visible

    def set_visible_nodes(self, nodes: list[str]):
        """
        Set list of visible nodes.

        Args:
            nodes: List of node IDs to make visible
        """
        # First, clear all visible flags
        for node_id, node_data in self._meta.get("nodes", {}).items():
            if "visible" in node_data:
                del node_data["visible"]

        # Then set visible=true for nodes in the list
        for node_id in nodes:
            if node_id not in self._meta["nodes"]:
                self._meta["nodes"][node_id] = {}
            self._meta["nodes"][node_id]["visible"] = True

        # Clean up empty node entries
        self._meta["nodes"] = {k: v for k, v in self._meta["nodes"].items() if v}

        self._save_meta()

    def add_node_to_canvas(self, node_id: str):
        """
        Add a node to the canvas (set visible=true).

        Idempotent - does nothing if node already visible.

        Args:
            node_id: Node ID to add
        """
        if node_id not in self._meta["nodes"]:
            self._meta["nodes"][node_id] = {}

        if not self._meta["nodes"][node_id].get("visible"):
            self._meta["nodes"][node_id]["visible"] = True
            self._save_meta()

    def add_nodes_to_canvas(self, node_ids: list[str]):
        """
        Add multiple nodes to the canvas.

        Idempotent - skips nodes already visible.

        Args:
            node_ids: List of node IDs to add
        """
        changed = False
        for node_id in node_ids:
            if node_id not in self._meta["nodes"]:
                self._meta["nodes"][node_id] = {}

            if not self._meta["nodes"][node_id].get("visible"):
                self._meta["nodes"][node_id]["visible"] = True
                changed = True

        if changed:
            self._save_meta()

    def remove_node_from_canvas(self, node_id: str):
        """
        Remove a node from the canvas (set visible=false/remove).

        Also removes the node's position.

        Args:
            node_id: Node ID to remove
        """
        changed = False

        # Remove visible flag
        if node_id in self._meta.get("nodes", {}):
            if "visible" in self._meta["nodes"][node_id]:
                del self._meta["nodes"][node_id]["visible"]
                changed = True
            # Clean up empty node entry
            if not self._meta["nodes"][node_id]:
                del self._meta["nodes"][node_id]

        # Also remove position
        canvas = self._meta.get("canvas", {})
        positions = canvas.get("positions", {})
        if node_id in positions:
            del positions[node_id]
            changed = True

        if changed:
            self._save_meta()

    def clear_canvas(self):
        """
        Clear canvas (all visible flags and positions).

        Keeps viewport unchanged.
        """
        # Clear all visible flags
        for node_id, node_data in list(self._meta.get("nodes", {}).items()):
            if "visible" in node_data:
                del node_data["visible"]
            # Clean up empty node entry
            if not node_data:
                del self._meta["nodes"][node_id]

        # Clear positions
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        else:
            self._meta["canvas"]["positions"] = {}

        self._save_meta()

    def get_positions(self) -> dict[str, dict]:
        """
        Get all node positions.

        Returns:
            Dict of node_id -> {x, y, z}
        """
        return self._meta.get("canvas", {}).get("positions", {})

    def set_positions(self, positions: dict[str, dict]):
        """
        Replace all positions.

        Args:
            positions: Dict of node_id -> {x, y, z}
        """
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        self._meta["canvas"]["positions"] = positions
        self._save_meta()

    def update_positions(self, positions: dict[str, dict]):
        """
        Merge new positions with existing ones.

        Args:
            positions: Dict of node_id -> {x, y, z} to merge
        """
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        existing = self._meta["canvas"].get("positions", {})
        existing.update(positions)
        self._meta["canvas"]["positions"] = existing
        self._save_meta()

    def delete_position(self, node_id: str):
        """
        Delete a single node's position.

        Args:
            node_id: Node ID
        """
        positions = self._meta.get("canvas", {}).get("positions", {})
        if node_id in positions:
            del positions[node_id]
            self._save_meta()

    def get_node_position(self, node_id: str) -> Optional[dict]:
        """
        Get position for a single node.

        Args:
            node_id: Node ID

        Returns:
            Position dict {x, y, z} or None if not found
        """
        return self._meta.get("canvas", {}).get("positions", {}).get(node_id)

    def get_viewport(self) -> dict:
        """
        Get viewport data.

        Returns:
            Viewport dict with camera_position, camera_target, zoom, etc.
        """
        viewport = self._meta.get("canvas", {}).get("viewport", {})
        # Merge with defaults to ensure all fields exist
        result = self.DEFAULT_VIEWPORT.copy()
        result.update(viewport)
        return result

    def set_viewport(self, viewport: dict):
        """
        Replace viewport data.

        Args:
            viewport: New viewport data
        """
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        self._meta["canvas"]["viewport"] = viewport
        self._save_meta()

    def update_viewport(self, partial: dict):
        """
        Partially update viewport (merge fields).

        Args:
            partial: Fields to update (None values are allowed to clear fields)
        """
        if "canvas" not in self._meta:
            self._meta["canvas"] = {
                "positions": {},
                "viewport": self.DEFAULT_VIEWPORT.copy(),
            }
        if "viewport" not in self._meta["canvas"]:
            self._meta["canvas"]["viewport"] = self.DEFAULT_VIEWPORT.copy()

        for key, value in partial.items():
            # Allow None values to clear fields like selected_node_id
            self._meta["canvas"]["viewport"][key] = value

        self._save_meta()
