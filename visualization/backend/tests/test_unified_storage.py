"""
Unified Storage Tests

Test the unified Node/Edge storage system:
- graph.json: Read-only, generated by Lean parser
- meta.json: Read/write, user data
- UnifiedStorage merges both to provide unified view
"""

import pytest
import json
import tempfile
import shutil
from pathlib import Path

from astrolabe.unified_storage import UnifiedStorage


# ============================================
# Mock Data
# ============================================

MOCK_GRAPH_DATA = {
    "version": "1.0",
    "ilean_hash": "test_hash",
    "nodes": [
        {
            "id": "Mathlib.Algebra.Field.Basic.div_add_div",
            "name": "div_add_div",
            "kind": "theorem",
            "file_path": "Mathlib/Algebra/Field/Basic.lean",
            "line_number": 123,
            "content": "theorem div_add_div...",
            "status": "proven",
            "references": ["Mathlib.Algebra.Ring.add_comm"],
            "depends_on_count": 1,
            "used_by_count": 5,
            "depth": 3
        },
        {
            "id": "Mathlib.Algebra.Ring.add_comm",
            "name": "add_comm",
            "kind": "theorem",
            "file_path": "Mathlib/Algebra/Ring/Basic.lean",
            "line_number": 45,
            "content": "theorem add_comm...",
            "status": "proven",
            "references": [],
            "depends_on_count": 0,
            "used_by_count": 10,
            "depth": 1
        }
    ],
    "edges": [
        {
            "source": "Mathlib.Algebra.Field.Basic.div_add_div",
            "target": "Mathlib.Algebra.Ring.add_comm"
        }
    ]
}


# ============================================
# Fixtures
# ============================================

@pytest.fixture
def temp_dir():
    """Create temporary directory"""
    temp = tempfile.mkdtemp()
    astrolabe_dir = Path(temp) / ".astrolabe"
    astrolabe_dir.mkdir()
    yield temp
    shutil.rmtree(temp)


@pytest.fixture
def meta_path(temp_dir):
    """Return meta.json path"""
    return Path(temp_dir) / ".astrolabe" / "meta.json"


@pytest.fixture
def storage(meta_path):
    """Create UnifiedStorage with mock graph data"""
    return UnifiedStorage(graph_data=MOCK_GRAPH_DATA, meta_path=meta_path)


@pytest.fixture
def storage_with_user_data(meta_path):
    """Create UnifiedStorage with mock graph data and preset user data"""
    # Preset some user data
    initial_meta = {
        "nodes": {
            "custom-1234567890": {
                "name": "Existing User Node",
                "kind": "custom",
                "references": [],
                "notes": "existing"
            }
        },
        "edges": {}
    }
    with open(meta_path, "w") as f:
        json.dump(initial_meta, f)

    return UnifiedStorage(graph_data=MOCK_GRAPH_DATA, meta_path=meta_path)


# ============================================
# 1. Node Operation Tests
# ============================================

class TestNodeOperations:
    """Node operation tests"""

    def test_add_user_node_creates_entry_in_meta(self, storage, meta_path):
        """Add User node, check it exists in meta.json"""
        node_id = "custom-my-theorem"

        result = storage.add_user_node(
            node_id=node_id,
            name="My Future Theorem",
            kind="custom",
            notes="This is a planned theorem",
        )

        # Check return value
        assert result["id"] == node_id
        assert result["name"] == "My Future Theorem"
        assert result["kind"] == "custom"
        assert result["notes"] == "This is a planned theorem"

        # Check meta.json file
        with open(meta_path, "r") as f:
            data = json.load(f)

        assert node_id in data["nodes"]
        assert data["nodes"][node_id]["name"] == "My Future Theorem"
        assert data["nodes"][node_id]["kind"] == "custom"
        assert data["nodes"][node_id]["notes"] == "This is a planned theorem"

    def test_add_user_node_requires_name_and_kind(self, storage):
        """Adding User node requires name and kind"""
        with pytest.raises(ValueError, match="name"):
            storage.add_user_node(node_id="custom-test", name="", kind="custom")

        with pytest.raises(ValueError, match="kind"):
            storage.add_user_node(node_id="custom-test", name="Test", kind="")

    def test_add_user_node_with_references(self, storage, meta_path):
        """Adding User node can include references"""
        node_id = "custom-with-refs"
        refs = ["Mathlib.Algebra.Field.Basic.div_add_div"]

        storage.add_user_node(
            node_id=node_id,
            name="Node With Refs",
            kind="custom",
            references=refs,
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert data["nodes"][node_id]["references"] == refs

    def test_update_lean_node_meta_only_stores_style_fields(self, storage, meta_path):
        """Update Lean node meta, only stores override properties"""
        node_id = "Mathlib.Algebra.Field.Basic.div_add_div"

        storage.update_node_meta(
            node_id,
            size=2.0,
            notes="Important theorem",
            pinned=True,
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert node_id in data["nodes"]
        assert data["nodes"][node_id]["size"] == 2.0
        assert data["nodes"][node_id]["notes"] == "Important theorem"
        assert data["nodes"][node_id]["pinned"] == True

    def test_update_lean_node_meta_does_not_store_name_kind(self, storage, meta_path):
        """Update Lean node meta, doesn't store name, kind, file_path, etc."""
        node_id = "Mathlib.Algebra.Field.Basic.div_add_div"

        # Even if passed name and kind, they should not be saved
        storage.update_node_meta(
            node_id,
            name="hacked_name",  # Should not save
            kind="hacked_kind",  # Should not save
            file_path="hacked",  # Should not save
            size=2.0,            # Should save
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert "name" not in data["nodes"][node_id]
        assert "kind" not in data["nodes"][node_id]
        assert "file_path" not in data["nodes"][node_id]
        assert data["nodes"][node_id]["size"] == 2.0

    def test_update_user_node_meta(self, storage_with_user_data, meta_path):
        """Update User node meta (including name)"""
        node_id = "custom-1234567890"

        storage_with_user_data.update_node_meta(
            node_id,
            name="Updated Name",
            notes="Updated notes",
            size=1.5,
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert data["nodes"][node_id]["name"] == "Updated Name"
        assert data["nodes"][node_id]["notes"] == "Updated notes"
        assert data["nodes"][node_id]["size"] == 1.5

    def test_delete_user_node_removes_from_meta(self, storage, meta_path):
        """Delete User node"""
        node_id = "custom-to-delete"
        storage.add_user_node(node_id, name="To Delete", kind="custom")

        # Confirm exists
        with open(meta_path, "r") as f:
            assert node_id in json.load(f)["nodes"]

        # Delete
        result = storage.delete_node(node_id)
        assert result == True

        # Confirm deleted
        with open(meta_path, "r") as f:
            assert node_id not in json.load(f)["nodes"]

    def test_delete_user_node_cascades_to_edges(self, storage, meta_path):
        """Deleting User node also deletes related edges"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        edge_id = "custom-a->custom-b"

        # Confirm edge exists
        with open(meta_path, "r") as f:
            assert edge_id in json.load(f)["edges"]

        # Delete node A
        storage.delete_node("custom-a")

        # Edge should also be deleted
        with open(meta_path, "r") as f:
            assert edge_id not in json.load(f)["edges"]

    def test_delete_lean_node_only_clears_meta(self, storage, meta_path):
        """Deleting Lean node only clears meta, doesn't truly delete"""
        node_id = "Mathlib.Algebra.Field.Basic.div_add_div"

        # First add some meta
        storage.update_node_meta(node_id, size=2.0, notes="test")

        # Confirm meta exists
        with open(meta_path, "r") as f:
            assert node_id in json.load(f)["nodes"]

        # Delete
        result = storage.delete_node(node_id)
        assert result == True

        # Meta should be cleared
        with open(meta_path, "r") as f:
            data = json.load(f)
            assert node_id not in data["nodes"]

        # But get_node should still return Lean data
        node = storage.get_node(node_id)
        assert node is not None
        assert node["name"] == "div_add_div"

    def test_get_node_meta_returns_none_for_unknown(self, storage):
        """Getting meta for nonexistent node returns None"""
        result = storage.get_node_meta("nonexistent-node")
        assert result is None

    def test_get_all_user_nodes_filters_by_prefix(self, storage):
        """Get all User nodes (custom- prefix)"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_node("custom-c", name="C", kind="custom")

        user_nodes = storage.get_all_user_nodes()

        assert len(user_nodes) == 3
        ids = [n["id"] for n in user_nodes]
        assert all(id.startswith("custom-") for id in ids)


# ============================================
# 2. Edge Operation Tests
# ============================================

class TestEdgeOperations:
    """Edge operation tests"""

    def test_add_user_edge_creates_entry_in_meta(self, storage, meta_path):
        """Add User edge, check meta.json"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")

        result = storage.add_user_edge("custom-a", "custom-b", notes="A depends on B")

        assert result["id"] == "custom-a->custom-b"
        assert result["source"] == "custom-a"
        assert result["target"] == "custom-b"

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert "custom-a->custom-b" in data["edges"]

    def test_add_user_edge_sets_type_custom(self, storage, meta_path):
        """Adding User edge sets type to custom"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")

        storage.add_user_edge("custom-a", "custom-b")

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert data["edges"]["custom-a->custom-b"]["type"] == "custom"

    def test_add_user_edge_updates_source_references(self, storage, meta_path):
        """Adding User edge updates source node's references"""
        storage.add_user_node("custom-a", name="A", kind="custom", references=[])
        storage.add_user_node("custom-b", name="B", kind="custom")

        storage.add_user_edge("custom-a", "custom-b")

        with open(meta_path, "r") as f:
            data = json.load(f)

        # custom-a's references should contain custom-b
        assert "custom-b" in data["nodes"]["custom-a"]["references"]

    def test_update_lean_edge_meta(self, storage, meta_path):
        """Update Lean edge meta"""
        edge_id = "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm"

        storage.update_edge_meta(
            edge_id,
            style="dashed",
            notes="Test note",
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert edge_id in data["edges"]
        assert data["edges"][edge_id]["style"] == "dashed"
        assert data["edges"][edge_id]["notes"] == "Test note"

    def test_update_user_edge_meta(self, storage, meta_path):
        """Update User edge meta"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        edge_id = "custom-a->custom-b"
        storage.update_edge_meta(
            edge_id,
            style="dashed",
            notes="Updated",
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert data["edges"][edge_id]["style"] == "dashed"
        assert data["edges"][edge_id]["notes"] == "Updated"

    def test_delete_user_edge_removes_from_meta(self, storage, meta_path):
        """Delete User edge"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        edge_id = "custom-a->custom-b"

        # Confirm exists
        with open(meta_path, "r") as f:
            assert edge_id in json.load(f)["edges"]

        # Delete
        result = storage.delete_edge(edge_id)
        assert result == True

        # Confirm deleted
        with open(meta_path, "r") as f:
            assert edge_id not in json.load(f)["edges"]

    def test_delete_user_edge_updates_source_references(self, storage, meta_path):
        """Deleting User edge updates source node's references"""
        storage.add_user_node("custom-a", name="A", kind="custom", references=[])
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        # Confirm references contains custom-b
        with open(meta_path, "r") as f:
            assert "custom-b" in json.load(f)["nodes"]["custom-a"]["references"]

        # Delete edge
        storage.delete_edge("custom-a->custom-b")

        # references should no longer contain custom-b
        with open(meta_path, "r") as f:
            assert "custom-b" not in json.load(f)["nodes"]["custom-a"]["references"]

    def test_delete_lean_edge_raises_error(self, storage):
        """Deleting Lean edge should raise error"""
        edge_id = "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm"

        with pytest.raises(ValueError, match="Cannot delete Lean edge"):
            storage.delete_edge(edge_id)

    def test_get_edge_meta_returns_none_for_unknown(self, storage):
        """Getting meta for nonexistent edge returns None"""
        result = storage.get_edge_meta("nonexistent->edge")
        assert result is None

    def test_get_all_user_edges_filters_by_type(self, storage):
        """Get all User edges (type=custom)"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_node("custom-c", name="C", kind="custom")

        storage.add_user_edge("custom-a", "custom-b")
        storage.add_user_edge("custom-b", "custom-c")

        user_edges = storage.get_all_user_edges()

        assert len(user_edges) == 2
        assert all(e.get("type") == "custom" for e in user_edges)


# ============================================
# 3. Cascade Operation Tests
# ============================================

class TestCascadeOperations:
    """Cascade operation tests"""

    def test_delete_node_deletes_outgoing_edges(self, storage, meta_path):
        """Deleting node deletes all edges where node is source"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_node("custom-c", name="C", kind="custom")

        storage.add_user_edge("custom-a", "custom-b")
        storage.add_user_edge("custom-a", "custom-c")

        storage.delete_node("custom-a")

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert "custom-a->custom-b" not in data["edges"]
        assert "custom-a->custom-c" not in data["edges"]

    def test_delete_node_deletes_incoming_edges(self, storage, meta_path):
        """Deleting node deletes all edges where node is target"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_node("custom-c", name="C", kind="custom")

        storage.add_user_edge("custom-b", "custom-a")
        storage.add_user_edge("custom-c", "custom-a")

        storage.delete_node("custom-a")

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert "custom-b->custom-a" not in data["edges"]
        assert "custom-c->custom-a" not in data["edges"]

    def test_delete_node_updates_other_nodes_references(self, storage, meta_path):
        """Deleting node removes references from other nodes"""
        storage.add_user_node("custom-a", name="A", kind="custom", references=[])
        storage.add_user_node("custom-b", name="B", kind="custom", references=[])
        storage.add_user_node("custom-c", name="C", kind="custom", references=[])

        # B and C both depend on A
        storage.add_user_edge("custom-b", "custom-a")
        storage.add_user_edge("custom-c", "custom-a")

        # Confirm B and C's references contain custom-a
        with open(meta_path, "r") as f:
            data = json.load(f)
            assert "custom-a" in data["nodes"]["custom-b"]["references"]
            assert "custom-a" in data["nodes"]["custom-c"]["references"]

        # Delete A
        storage.delete_node("custom-a")

        # B and C's references should no longer contain custom-a
        with open(meta_path, "r") as f:
            data = json.load(f)
            assert "custom-a" not in data["nodes"]["custom-b"]["references"]
            assert "custom-a" not in data["nodes"]["custom-c"]["references"]


# ============================================
# 4. Data Merge Tests
# ============================================

class TestDataMerge:
    """Test merging graph.json and meta.json"""

    def test_get_all_nodes_includes_lean_nodes(self, storage):
        """get_all_nodes includes Lean nodes"""
        nodes = storage.get_all_nodes()
        ids = [n["id"] for n in nodes]

        assert "Mathlib.Algebra.Field.Basic.div_add_div" in ids
        assert "Mathlib.Algebra.Ring.add_comm" in ids

    def test_get_all_nodes_includes_user_nodes(self, storage):
        """get_all_nodes includes User nodes"""
        storage.add_user_node("custom-test", name="Test", kind="custom")

        nodes = storage.get_all_nodes()
        ids = [n["id"] for n in nodes]

        assert "custom-test" in ids

    def test_get_all_nodes_merges_lean_with_meta(self, storage):
        """get_all_nodes merges Lean data with meta"""
        node_id = "Mathlib.Algebra.Field.Basic.div_add_div"
        storage.update_node_meta(node_id, size=2.0, notes="Custom note")

        nodes = storage.get_all_nodes()
        node = next(n for n in nodes if n["id"] == node_id)

        # From Lean
        assert node["name"] == "div_add_div"
        assert node["kind"] == "theorem"
        assert node["file_path"] == "Mathlib/Algebra/Field/Basic.lean"

        # From meta
        assert node["size"] == 2.0
        assert node["notes"] == "Custom note"

    def test_get_all_edges_includes_lean_edges(self, storage):
        """get_all_edges includes Lean edges"""
        edges = storage.get_all_edges()
        ids = [e["id"] for e in edges]

        assert "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm" in ids

    def test_get_all_edges_includes_user_edges(self, storage):
        """get_all_edges includes User edges"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        edges = storage.get_all_edges()
        ids = [e["id"] for e in edges]

        assert "custom-a->custom-b" in ids

    def test_get_all_edges_merges_lean_with_meta(self, storage):
        """get_all_edges merges Lean data with meta"""
        edge_id = "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm"
        storage.update_edge_meta(edge_id, style="dashed", notes="Test")

        edges = storage.get_all_edges()
        edge = next(e for e in edges if e["id"] == edge_id)

        # From Lean
        assert edge["source"] == "Mathlib.Algebra.Field.Basic.div_add_div"
        assert edge["target"] == "Mathlib.Algebra.Ring.add_comm"

        # From meta
        assert edge["style"] == "dashed"
        assert edge["notes"] == "Test"

    def test_get_node_returns_merged_lean_node(self, storage):
        """get_node returns merged Lean node"""
        node_id = "Mathlib.Algebra.Field.Basic.div_add_div"
        storage.update_node_meta(node_id, size=2.0)

        node = storage.get_node(node_id)

        assert node["id"] == node_id
        assert node["name"] == "div_add_div"  # From Lean
        assert node["size"] == 2.0            # From meta

    def test_get_node_returns_user_node(self, storage):
        """get_node returns User node"""
        storage.add_user_node("custom-test", name="Test", kind="custom", notes="My note")

        node = storage.get_node("custom-test")

        assert node["id"] == "custom-test"
        assert node["name"] == "Test"
        assert node["kind"] == "custom"
        assert node["notes"] == "My note"

    def test_get_node_returns_none_for_unknown(self, storage):
        """get_node returns None for nonexistent node"""
        node = storage.get_node("nonexistent-node")
        assert node is None

    def test_get_edge_returns_merged_lean_edge(self, storage):
        """get_edge returns merged Lean edge"""
        edge_id = "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm"
        storage.update_edge_meta(edge_id, style="dashed")

        edge = storage.get_edge(edge_id)

        assert edge["id"] == edge_id
        assert edge["source"] == "Mathlib.Algebra.Field.Basic.div_add_div"
        assert edge["style"] == "dashed"

    def test_get_edge_returns_user_edge(self, storage):
        """get_edge returns User edge"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b", notes="Test edge")

        edge = storage.get_edge("custom-a->custom-b")

        assert edge["id"] == "custom-a->custom-b"
        assert edge["source"] == "custom-a"
        assert edge["target"] == "custom-b"
        assert edge["type"] == "custom"
        assert edge["notes"] == "Test edge"


# ============================================
# 5. Helper Method Tests
# ============================================

class TestHelperMethods:
    """Helper method tests"""

    def test_is_user_node_true_for_user_prefix(self, storage):
        """custom- prefix is User node"""
        assert storage.is_user_node("custom-12345") == True
        assert storage.is_user_node("custom-my-theorem") == True

    def test_is_user_node_false_for_lean_node(self, storage):
        """Lean node is not User node"""
        assert storage.is_user_node("Mathlib.Algebra.Field.Basic.div_add_div") == False

    def test_is_lean_node_true_for_module_prefix(self, storage):
        """Module name format is Lean node"""
        assert storage.is_lean_node("Mathlib.Algebra.Field.Basic.div_add_div") == True

    def test_is_user_edge_true_for_custom_type(self, storage, meta_path):
        """type=custom is User edge"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        assert storage.is_user_edge("custom-a->custom-b") == True

    def test_is_lean_edge_true_for_reference_type(self, storage):
        """Lean edge is reference type"""
        edge_id = "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm"
        assert storage.is_lean_edge(edge_id) == True


# ============================================
# 6. Data Structure Validation Tests
# ============================================

class TestDataStructureValidation:
    """Data structure validation tests"""

    def test_user_node_structure_has_required_fields(self, storage, meta_path):
        """User node must have name, kind, references"""
        storage.add_user_node(
            "custom-test",
            name="Test",
            kind="custom",
            references=["some-ref"],
        )

        with open(meta_path, "r") as f:
            data = json.load(f)

        node = data["nodes"]["custom-test"]
        assert "name" in node
        assert "kind" in node
        assert "references" in node

    def test_lean_node_meta_excludes_identity_fields(self, storage, meta_path):
        """Lean node meta doesn't store identity fields like name, kind, file_path"""
        node_id = "Mathlib.Algebra.Field.Basic.div_add_div"
        storage.update_node_meta(node_id, size=2.0, notes="test")

        with open(meta_path, "r") as f:
            data = json.load(f)

        node_meta = data["nodes"][node_id]
        assert "name" not in node_meta
        assert "kind" not in node_meta
        assert "file_path" not in node_meta
        assert "line_number" not in node_meta
        assert "status" not in node_meta
        assert "content" not in node_meta

    def test_edge_id_format_is_source_arrow_target(self, storage):
        """Edge ID format is source->target"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")

        result = storage.add_user_edge("custom-a", "custom-b")

        assert result["id"] == "custom-a->custom-b"
        assert "->" in result["id"]

    def test_user_edge_type_is_custom(self, storage, meta_path):
        """User edge type is custom"""
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        with open(meta_path, "r") as f:
            data = json.load(f)

        assert data["edges"]["custom-a->custom-b"]["type"] == "custom"

    def test_lean_edge_type_is_reference(self, storage):
        """Lean edge type is reference (from graph.json)"""
        edge_id = "Mathlib.Algebra.Field.Basic.div_add_div->Mathlib.Algebra.Ring.add_comm"
        edge = storage.get_edge(edge_id)

        # Lean edge default type is reference
        assert edge.get("type") == "reference"


# ============================================
# 7. Mixed Scenario Tests
# ============================================

class TestMixedScenarios:
    """User nodes and Lean nodes mixed usage"""

    def test_user_edge_to_lean_node(self, storage, meta_path):
        """User edge can connect to Lean node"""
        storage.add_user_node("custom-my-theorem", name="My Theorem", kind="custom")

        lean_node_id = "Mathlib.Algebra.Field.Basic.div_add_div"
        storage.add_user_edge("custom-my-theorem", lean_node_id)

        edge = storage.get_edge(f"custom-my-theorem->{lean_node_id}")
        assert edge is not None
        assert edge["type"] == "custom"

    def test_user_node_references_lean_node(self, storage, meta_path):
        """User node references can include Lean nodes"""
        lean_node_id = "Mathlib.Algebra.Field.Basic.div_add_div"

        storage.add_user_node(
            "custom-my-theorem",
            name="My Theorem",
            kind="custom",
            references=[lean_node_id],
        )

        node = storage.get_node("custom-my-theorem")
        assert lean_node_id in node["references"]

    def test_delete_user_node_with_edge_to_lean_node(self, storage, meta_path):
        """Delete User node with edge connected to Lean node"""
        storage.add_user_node("custom-my-theorem", name="My Theorem", kind="custom")
        lean_node_id = "Mathlib.Algebra.Field.Basic.div_add_div"
        storage.add_user_edge("custom-my-theorem", lean_node_id)

        edge_id = f"custom-my-theorem->{lean_node_id}"

        # Delete User node
        storage.delete_node("custom-my-theorem")

        # Node and edge should be deleted
        assert storage.get_node("custom-my-theorem") is None
        assert storage.get_edge(edge_id) is None

        # Lean node unaffected
        assert storage.get_node(lean_node_id) is not None

    def test_count_nodes_and_edges(self, storage):
        """Count nodes and edges"""
        # Initial state: 2 Lean nodes, 1 Lean edge
        assert len(storage.get_all_nodes()) == 2
        assert len(storage.get_all_edges()) == 1

        # Add User data
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_node("custom-b", name="B", kind="custom")
        storage.add_user_edge("custom-a", "custom-b")

        # Now: 4 nodes, 2 edges
        assert len(storage.get_all_nodes()) == 4
        assert len(storage.get_all_edges()) == 2

        # Only User nodes/edges
        assert len(storage.get_all_user_nodes()) == 2
        assert len(storage.get_all_user_edges()) == 1


# ============================================
# ============================================
# 8. Clear Operation Tests
# ============================================

class TestClearOperation:
    """Clear operation tests"""

    def test_clear_removes_all_data(self, storage, meta_path):
        """clear clears all meta data"""
        # Add various data
        storage.add_user_node("custom-a", name="A", kind="custom")
        storage.add_user_edge("custom-a", "Mathlib.Algebra.Field.Basic.div_add_div")
        storage.update_node_meta("Mathlib.Algebra.Field.Basic.div_add_div", size=2.0)

        # Clear
        storage.clear()

        # Verify
        with open(meta_path, "r") as f:
            data = json.load(f)

        assert data["nodes"] == {}
        assert data["edges"] == {}

    def test_clear_preserves_lean_data(self, storage):
        """clear doesn't affect Lean data (graph_data)"""
        storage.clear()

        # Lean nodes still exist
        nodes = storage.get_all_nodes()
        assert len(nodes) == 2  # 2 Lean nodes

        # Lean edges still exist
        edges = storage.get_all_edges()
        assert len(edges) == 1  # 1 Lean edge
